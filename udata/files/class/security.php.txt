<?php
/* This file is part of UData.
 * Copyright (C) 2018 Paul W. Lane <kc9eye@outlook.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
Class Security {
    const BAD_USERNAME = 2112;
    const BAD_PASSWORD = 1221;
    const COOKIE_ID = 'UDIDIT';

    private $dbh;
    private $persistentid;
    public $secureUserID;
    public $user;

    public function __construct (PDO $dbh) {
        $this->dbh = $dbh;
        $this->secureUserID = null;
        $this->user = null;
    }

    public function setUser () {
        $test = $this->dbh->prepare('SELECT COUNT(*) FROM user_accts WHERE id = ?');
        $test->execute([$this->secureUserID]);
        $res = $test->fetchAll(PDO::FETCH_ASSOC);

        if ($res[0]['count'] > 1) {
            throw new Exception("User id has more than 1 entry, database is corrupted");
        }
        elseif ($res[0]['count'] == 0) {
            return false;
        }
        elseif ($res[0]['count'] == 1) {
            $pntr = $this->dbh->prepare('SELECT * FROM user_accts WHERE id = ?');
            $pntr->execute([$this->secureUserID]);
            $user = $pntr->fetchAll(PDO::FETCH_ASSOC)[0];
            $this->user['email'] = $user['username'];
            $this->user['firstname'] = $user['firstname'];
            $this->user['lastname'] = $user['lastname'];
            $this->user['alt_email'] = $user['alt_email'];
            $this->user['uid'] = $user['id'];
        }
    }

    /*
        Checks whether or not a persistent log on exists
        and validates if it does.
        [ bool checkPersistentLogOn() ];
    */
    public function checkPersistentLogOn () {
        #Verify the cache exists
        if (! isset($_COOKIE[self::COOKIE_ID]) ) {
            return false;
        }

        $split = explode(':', $_COOKIE[self::COOKIE_ID]);

        #Get the log in data and verify
        $sql = 'SELECT * FROM auth_tokens WHERE selector = ?';
        $pntr = $this->dbh->prepare($sql);
        $pntr->execute([$split[0]]);
        $res = $pntr->fetchAll(PDO::FETCH_ASSOC)[0];

        if ( hash_equals( hash('sha256', $split[1]), $res['validator'] ) ) {
            #Reset the data cache and exit if valid
            $this->secureUserID = $res['uid'];
            $this->persistentid = $res['id'];
            $this->updatePersistentLogOn();
            return true;
        }
        else {
            return false;
        }
    }

    /*
        Verify's a given username and passowrd
        [mixed verifyLogOn([string $username], [string $password])]
        Returns true on success, failure code on failure, or false for errors
    */
    public function verifyLogOn ($username, $password) {
        #Verify the username exists
        if (! $this->verifyUsername($username)) {
            return self::BAD_USERNAME;
        }
        
        #Get users account data
        $sql = 'SELECT * FROM user_accts WHERE username = ?';
        $pntr = $this->dbh->prepare($sql);
        $pntr->execute([$username]);
        $res = $pntr->fetchAll(PDO::FETCH_ASSOC)[0];

        #Verify correct password
        if (password_verify($password, $res['password'])) {
            $this->secureUserID = $res['id'];
            return true;
        }
        else {
            return self::BAD_PASSWORD;
        }
        return false;
    }

    public function setPersistentLogOn ($uid) {
        $selector = hash('sha256', uniqid());
        $validator = bin2hex(random_bytes(32));
        $this->persistentid = uniqid();
        $dataCache = array(
            ':selector' => $selector,
            ':validator' => hash('sha256', $validator),
            ':id' => $this->persistentid,
            ':uid' => $uid
        );

        $sql = 'INSERT INTO auth_tokens VALUES (:id,NOW(),:selector,:validator,:uid)';
        $pntr = $this->dbh->prepare($sql);
        $pntr->execute($dataCache);
        if ($pntr->rowCount() < 1) {
            throw new Exception('Unable to insert persistent data into datbase');
        }
        setcookie(self::COOKIE_ID, $selector.':'.$validator, time()+(60*60*24*365), "/");
        return true;
    }

    public function deletePersistentLogOn () {
        $sql = 'DELETE FROM auth_tokens WHERE uid = ?';
        $pntr = $this->dbh->prepare($sql);
        $pntr->execute([$this->secureUserID]);
        if ($pntr->rowcount() >= 1) {
            setcookie(self::COOKIE_ID, '', time() - 1, '/');
            return true;
        }
        else {
            throw new Exception('Unable to delete database entry for persistent cookie data for user: '.$this->secureUserID);
        }
        return false;
    }

    /* 
        Updates a persistent log on cache.
        [bool updatePersistentLogOn([string $dataID])]
    */
    protected function updatePersistentLogOn () {
        $selector = hash('sha256', uniqid());
        $validator = bin2hex(random_bytes(32));
        $dataCache = array(
            ':selector' => $selector,
            ':validator' => hash('sha256', $validator),
            ':date' => 'NOW()',
            ':id' => $this->persistentid
        );

        $sql = 'UPDATE auth_tokens SET _date = :date, selector = :selector, validator = :validator WHERE id = :id';
        $pntr = $this->dbh->prepare($sql);
        $pntr->execute($dataCache);
        if ($pntr->rowCount() == 0) {
            throw new Exception('Updating persistent logon record failed.');
        }
        elseif (! setcookie(self::COOKIE_ID, $selector.':'.$validator, time()+60*60*24*365, "/")) {
            throw new Exception('Unable to update persistent logon cookie, cookie\'s in use?');
        }
        else {
            return true;
        }
    }

    /*
        Verify's whther or not a username appears in the database exactly once
        [bool verifyUsername( [string $username] )]
    */
    protected function verifyUsername ($username) {
        $sql = 'SELECT count(*) FROM user_accts WHERE username = ?';
        $pntr = $this->dbh->prepare($sql);
        $pntr->execute([$username]);
        $res = $pntr->fetchAll(PDO::FETCH_ASSOC);
        if ($res[0]['count'] == 0) {
            return false;
        }
        elseif ($res[0]['count'] > 1) {
            throw new Exception('More than one user with same username, database corrupt');
        }
        else {
            return true;
        }
    }

    public function userHasRole ($role) {
        if (is_null($this->secureUserID)) {
            return false;
        }
        try {
            $sql = 'SELECT count(roles.id) FROM roles
                    INNER JOIN user_roles ON user_roles.rid = roles.id
                    WHERE user_roles.uid = :uid AND
                    roles.name = :name';
            $pntr = $this->dbh->prepare($sql);
            $pntr->execute([':uid'=>$this->secureUserID,':name'=>$role]);
            $res = $pntr->fetch(PDO::FETCH_ASSOC);
            if ($res['count'] >= 1) {
                return true;
            }
            return false;
        }
        catch (PDOException $e) {
            trigger_error($e->message, E_USER_WARNING);
            return false;
        }
    }

    public function userHasPermission ($permission) {
        if (is_null($this->secureUserID)) {
            return false;
        }
        try {
            $sql = 'SELECT count(id) FROM roles
                    INNER JOIN user_roles ON user_roles.rid = roles.id
                    WHERE user_roles.uid = :uid AND
                    user_roles.rid IN (
                        SELECT user_roles.rid FROM user_roles
                        INNER JOIN role_perms ON role_perms.rid = user_roles.rid
                        WHERE role_perms.pid IN (
                            SELECT perms.id FROM perms
                            WHERE perms.name = :perm
                        )
                    )';
            $pntr = $this->dbh->prepare($sql);
            $pntr->execute([':uid'=>$this->secureUserID,':perm'=>$permission]);
            $res = $pntr->fetch(PDO::FETCH_ASSOC);
            if ($res['count'] >= 1) {
                return true;
            }
            return false;
        }
        catch (PDOException $e) {
            trigger_error($e->message, E_USER_NOTICE);
            return false;
        }
    }

    public function getUsersByPerm ($perm) {
        try {
            $sql = 'SELECT DISTINCT 
            user_accts.id, user_accts.username,
            user_accts.password, user_accts.firstname, 
            user_accts.lastname, user_accts.alt_email
            FROM user_accts
            INNER JOIN user_roles ON user_roles.uid = user_accts.id
            WHERE user_roles.rid IN (
                SELECT role_perms.rid FROM role_perms
                INNER JOIN perms ON perms.id = role_perms.pid
                WHERE perms.name = ?
            )';
            $pntr = $this->dbh->prepare($sql);
            $pntr->execute([$perm]);
            return $pntr->fetchAll(PDO::FETCH_ASSOC);
        }
        catch (PDOException $e) {
            trigger_error($e->message,E_USER_WARNING);
            return false;
        }
    }

    public function getUsersByRole ($role) {
        try {
            $sql = 'SELECT DISTINCT user_accts.id,user_accts.username,user_accts.password,user_accts.firstname,user_accts.lastname,user_accts.alt_email
                    FROM user_accts
                    INNER JOIN user_roles ON user_roles.uid = user_accts.id
                    WHERE user_roles.rid = (
                        SELECT roles.id FROM roles WHERE roles.name = ?
                    )';
            $pntr = $this->dbh->prepare($sql);
            $pntr->execute([$role]);
            return $pntr->fetchAll(PDO::FETCH_ASSOC);
        }
        catch (PDOException $e) {
            trigger_error($e->message,E_USER_WARNING);
            return false;
        }
    }
}
